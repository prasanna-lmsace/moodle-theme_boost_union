{"version":3,"file":"scrollspy.min.js","sources":["../src/scrollspy.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Theme Boost Union - JS code scroll-spy\r\n *\r\n * @module     theme_boost_union/scrollspy\r\n * @copyright  2022 Josha Bartsch <bartsch@itc.rwth-aachen.de>\r\n * @copyright  based on code from theme_fordson by Chris Kenniburg.\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\n/**\r\n * Runs once at initial load, and once at editmode-switch toggle.\r\n * Incase of initial load, checks sessionStorage whether a position was set and jumps to the appropriate position.\r\n *\r\n * Incase of a click on the switch, iterates over central elements (selector .section.main), determines element\r\n * with minimal distance between pixel-toprow of view and pixel-toprow of the element.\r\n * Writes element ID + distance of view from element into session storage.\r\n *\r\n * Saving a reference point + relative distance grants leeway for varying page elements.\r\n * (See original implementation: https://raw.githubusercontent.com/dbnschools/moodle-theme_fordson/master/javascript/scrollspy.js)\r\n */\r\nconst initScrollSpy = () => {\r\n    // Check if .section.main exist.\r\n    if (document.querySelector('.section.main')) {\r\n        // Unfortunately the editmode-switch carries no unique ID\r\n        let editToggle = document.querySelector('form.editmode-switch-form');\r\n        if (!editToggle) {\r\n            // Do not continue when there is no edit toggle.\r\n            return;\r\n        }\r\n        editToggle.addEventListener('click', () => {\r\n\r\n            window.sessionStorage.setItem('edittoggled', true);\r\n\r\n            let viewporttop = window.scrollY;\r\n            let closest = null;\r\n            let closestoffset = null;\r\n\r\n            document.querySelectorAll('.section.main').forEach((node) => {\r\n                let thisoffset = node.offsetTop;\r\n\r\n                if (closest && closest.offsetTop) {\r\n                    closestoffset = closest.offsetTop;\r\n                }\r\n                if (closest === null || Math.abs(thisoffset - viewporttop) < Math.abs(closestoffset - viewporttop)) {\r\n                    closest = node;\r\n                }\r\n            });\r\n\r\n            window.sessionStorage.setItem('closestid', closest.id);\r\n            window.sessionStorage.setItem('closestdelta', viewporttop - closest.offsetTop);\r\n        });\r\n        let edittoggled = window.sessionStorage.getItem('edittoggled');\r\n        if (edittoggled) {\r\n\r\n            let closestid = window.sessionStorage.getItem('closestid');\r\n            let closestdelta = window.sessionStorage.getItem('closestdelta');\r\n\r\n            if (closestid && closestdelta) {\r\n                let closest = document.getElementById(closestid);\r\n                let y = closest.offsetTop + parseInt(closestdelta);\r\n\r\n                window.scrollTo(0, y);\r\n            }\r\n\r\n            window.sessionStorage.removeItem('edittoggled');\r\n            window.sessionStorage.removeItem('closestid');\r\n            window.sessionStorage.removeItem('closestdelta');\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Ensures the passed function will be called after the DOM is ready/loaded:\r\n * Incase DOM is fully loaded when JS is called, call within next tick.\r\n * Otherwise sets an eventlistener for DOMEventLoaded\r\n *\r\n * @param {*} callback\r\n */\r\nconst docReady = (callback) => {\r\n    if (document.readyState === \"complete\" || document.readyState === \"interactive\") {\r\n        setTimeout(callback, 1);\r\n    } else {\r\n        document.addEventListener('DOMContentLoaded', callback);\r\n    }\r\n};\r\n\r\nexport const init = () => {\r\n    docReady(initScrollSpy);\r\n};\r\n"],"names":["initScrollSpy","document","querySelector","editToggle","addEventListener","window","sessionStorage","setItem","viewporttop","scrollY","closest","closestoffset","querySelectorAll","forEach","node","thisoffset","offsetTop","Math","abs","id","getItem","closestid","closestdelta","y","getElementById","parseInt","scrollTo","removeItem","callback","readyState","setTimeout"],"mappings":";;;;;;;;;MAmCMA,cAAgB,QAEdC,SAASC,cAAc,iBAAkB,KAErCC,WAAaF,SAASC,cAAc,iCACnCC,qBAILA,WAAWC,iBAAiB,SAAS,KAEjCC,OAAOC,eAAeC,QAAQ,eAAe,OAEzCC,YAAcH,OAAOI,QACrBC,QAAU,KACVC,cAAgB,KAEpBV,SAASW,iBAAiB,iBAAiBC,SAASC,WAC5CC,WAAaD,KAAKE,UAElBN,SAAWA,QAAQM,YACnBL,cAAgBD,QAAQM,YAEZ,OAAZN,SAAoBO,KAAKC,IAAIH,WAAaP,aAAeS,KAAKC,IAAIP,cAAgBH,gBAClFE,QAAUI,SAIlBT,OAAOC,eAAeC,QAAQ,YAAaG,QAAQS,IACnDd,OAAOC,eAAeC,QAAQ,eAAgBC,YAAcE,QAAQM,cAEtDX,OAAOC,eAAec,QAAQ,eAC/B,KAETC,UAAYhB,OAAOC,eAAec,QAAQ,aAC1CE,aAAejB,OAAOC,eAAec,QAAQ,mBAE7CC,WAAaC,aAAc,KAEvBC,EADUtB,SAASuB,eAAeH,WACtBL,UAAYS,SAASH,cAErCjB,OAAOqB,SAAS,EAAGH,GAGvBlB,OAAOC,eAAeqB,WAAW,eACjCtB,OAAOC,eAAeqB,WAAW,aACjCtB,OAAOC,eAAeqB,WAAW,iCAoBzB,KARFC,IAAAA,SAAAA,SASL5B,cARmB,aAAxBC,SAAS4B,YAAqD,gBAAxB5B,SAAS4B,WAC/CC,WAAWF,SAAU,GAErB3B,SAASG,iBAAiB,mBAAoBwB"}